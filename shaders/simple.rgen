#version 460
#extension GL_EXT_ray_tracing : require

#include "common.glsl"
#include "random.glsl"

layout(set = 0, binding = 0) uniform accelerationStructureEXT scene;

layout(set = 0, binding = 1, rgba8) uniform image2D result;

layout(set = 0, binding = 2, std140) uniform SceneUniformsBlock 
{
	SceneUniforms ubo;
};

layout(location = 0) rayPayloadEXT HitPayload payload;

vec2 subpixel_jitter(uint seed, uint samples)
{
	// jitter sample
	float r0 = random_float(seed);
	float r1 = random_float(seed);
	vec2 jitter = samples == 0 ? vec2(0.5) : vec2(r0, r1);
	return jitter;
}

vec4 srgb_to_linear(vec4 v)
{
	return pow(v, vec4(2.2));
}

vec4 linear_to_srgb(vec4 v)
{
	return pow(v, vec4(1.0/2.2));
}

void main()
{
	uvec2 index = gl_LaunchIDEXT.xy;
	uvec2 dims = gl_LaunchSizeEXT.xy;
	uint seed = random_tea(index.y * dims.x + index.x, ubo.samples_accum);

	vec2 jitter = subpixel_jitter(seed, ubo.samples_accum);

	vec2 d = (vec2(index) + jitter) / vec2(dims);
	// go to [-1, +1]
	d = 2.0 * d - 1.0;

	vec3 origin = (ubo.iview * vec4(0, 0, 0, 1.0)).xyz;
	vec4 target = ubo.iproj * vec4(d.x, d.y, 1.0, 1.0);
	vec3 dir = (ubo.iview * vec4(target.xyz, 0.0)).xyz;

	const uint ray_flags = gl_RayFlagsOpaqueEXT;
	
	// init payload
	payload.seed = seed;
	payload.ray_dir = dir;
	vec3 color = vec3(1.0);

	const uint max_depth = 8u;
	uint depth = 0u;
	while (depth < max_depth) {
	    vec3 prev_ray_dir = payload.ray_dir;
		traceRayEXT(scene, ray_flags, 0xFF, 0, 2, 0, origin, 0.01, payload.ray_dir, 100.0, 0);
		// update ray origin
		origin += payload.ray_t * prev_ray_dir;
		vec3 scatter_color = payload.scatters ? payload.scatter_color : vec3(0.0);
		vec3 emissive_color = payload.emits ? payload.emissive_color : vec3(0.0);
		color *= scatter_color + emissive_color;
		if (!payload.scatters) {
			break;
		}
		depth++;
		if (depth == max_depth) {
			// exceeded bounce limit, no more light is gathered
			color = vec3(0.0);
		}
	}

	if (ubo.samples_accum > 0) { // uniform branching
		const float accumulator = 1.0 / float(ubo.samples_accum + 1);
		vec3 accum_color = imageLoad(result, ivec2(index)).rgb;
		accum_color = srgb_to_linear(vec4(accum_color, 0.0)).rgb;
		color = mix(accum_color, color, accumulator);
	}

	color = linear_to_srgb(vec4(color, 0.0)).rgb;
	imageStore(result, ivec2(index), vec4(color, 1.0));
}

